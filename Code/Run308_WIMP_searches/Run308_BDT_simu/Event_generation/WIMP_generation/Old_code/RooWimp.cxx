/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooWimp.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TGraph.h"
#include "TFile.h"
#include "TF1.h"


ClassImp(RooWimp) 

 RooWimp::RooWimp(const char *name, const char *title, 
                        RooAbsReal& _Er,
                        RooAbsReal& _Mchi,
                        RooAbsReal& _sigma_nuc,
                        RooAbsReal& _A,
                        RooAbsReal& _v0,
                        RooAbsReal& _vesc) :
   RooAbsPdf(name,title), 
   Er("Er","Er",this,_Er),
   Mchi("Mchi","Mchi",this,_Mchi),
   sigma_nuc("sigma_nuc","sigma_nuc",this,_sigma_nuc),
   A("A","A",this,_A),
   v0("v0","v0",this,_v0),
   vesc("vesc","vesc",this,_vesc)
 {

 } 

 RooWimp::RooWimp(const RooWimp& other, const char* name) :  
   RooAbsPdf(other,name), 
   Er("Er",this,other.Er),
   Mchi("Mchi",this,other.Mchi),
   sigma_nuc("sigma_nuc",this,other.sigma_nuc),
   A("A",this,other.A),
   v0("v0",this,other.v0),
   vesc("vesc",this,other.vesc)
   
 {

 } 


 Double_t RooWimp::evaluate() const 
 { 
double rate=0; 

const double rho=0.3;
const double vearth=232;

const double pi=TMath::Pi();

// Velocity distribution integral from Phys Rev D 74, 043531 (2006), Savage, Freese, Gondolo


double Mn=0.932*A ;         // mass of target nucleus, 1 amu = 931.46 MeV/c^2 = 0.93146 GeV/c^2
double Mp=0.938 ;           // proton mass in GeV/c^2
double Erec=Er+0.00001;	    // Avoid null value

// Units: Er keV; Mn,Mchi GeV; v0,vesc km/s; rho GeV/cm^3; sigma pb
// rate evts/kg.d.keV
double eV=1.6E-19;              // [J]
double keV=eV*1E3;
double GeV=eV*1E9;
double fm=1E-15;
double pb=1E-40 ;              // 1 picobarn=10^-40 m^2
double hbarc=1.054E-34*3.e8;    // [J*m]
double kmpersec=1000;          // [m/s]
double cm3=1E6;                // [m^3]
double c2=9E16;                // [m^2/s^2]

// SPIN-IDEPENDENT COHERENT DIFFUSION, f_n=f_p
double mu=Mchi*Mn/(Mchi+Mn);                  // WIMP-nucleus reduced mass, in real units it would be mu=Mchi*Mn*GeV/((Mchi+Mn)*c2)
double mup=Mchi*Mp/(Mchi+Mp);                 // WIMP-proton  reduced mass, in real units it would be mup=Mchi*Mp*GeV/((Mchi+Mp)*c2)
double shigma=sigma_nuc*pow(mu/mup,2)*pow(A,2);            // [m^2]


// NUCLEAR FORM FACTOR (from Lewin & Smith, 1996)
double q=sqrt(2*Mn*GeV*Erec*keV) ;                   							// [MeV], array
double ss=0.9*fm;											//Lewin p. 98
double aa=0.52*fm	;										//Lewin p. 98
double cc=(1.23*pow(A,1./3.)-0.6)*fm;
double rn=sqrt(pow(cc,2)+(7/3.)*pow(pi,2)*pow(aa,2)-5.*pow(ss,2));                            		// Lewin (4.11)
double qrn=q*rn/hbarc;
double formfactor=3*exp(-pow(q*ss/hbarc,2)/2.)*(sin(qrn)-qrn*cos(qrn))/(pow(qrn,3)) ;  			// Lewin (4.7)

// Vmin CALCULATION
double vmin=sqrt(Mn*Erec*keV*c2/(2*pow(mu,2)*GeV))/kmpersec;


// RATE CALCULATION
double eta=0;
double x=vmin/v0;                          			// Adimensional velocities, SFG (12)
double y=vearth/v0;
double z=vesc/v0;

double w1=TMath::Abs(y-z);
double w2=y+z;


double Nesc=TMath::Erf(z)-2.*z*exp(-pow(z,2))/sqrt(pi);		//  Normalisation constant, SFG (8)

if (z< y && x<w1) {eta=1./(v0*y); }
else if (z> y && x<w1) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(x+y)-TMath::Erf(x-y)-4.*y*exp(-pow(z,2))/sqrt(pi)); }
else if (w1 <= x && x<w2) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(z)-TMath::Erf(x-y)-2.*(y+z-x)*exp(-pow(z,2))/sqrt(pi)); }
else if (w2<=x) {eta=0;}


rate=pb*shigma*pow(formfactor,2)*rho*cm3*pow(c2,2)*(eta)*3600*24/(2*Mchi*pow(mu,2)*GeV*1.E6*kmpersec);  // [counts/kg/day/keV]

return rate; 
 } 



