/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooWimpNew.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TGraph.h"
#include "TFile.h"
#include "TF1.h"


ClassImp(RooWimpNew) 

 RooWimpNew::RooWimpNew(const char *name, const char *title, 
                        RooAbsReal& _Er,
                        RooAbsReal& _Mchi,
                        RooAbsReal& _sigma_nuc,
                        RooAbsReal& _A,
                        RooAbsReal& _v0,
                        RooAbsReal& _vesc,
                        TF1* func) :
   RooAbsPdf(name,title), 
   Er("Er","Er",this,_Er),
   Mchi("Mchi","Mchi",this,_Mchi),
   sigma_nuc("sigma_nuc","sigma_nuc",this,_sigma_nuc),
   A("A","A",this,_A),
   v0("v0","v0",this,_v0),
   vesc("vesc","vesc",this,_vesc)
 {
 TF1 tmpfonc(*func);
 n_func= tmpfonc; 
 } 


 RooWimpNew::RooWimpNew(const RooWimpNew& other, const char* name) :  
   RooAbsPdf(other,name), 
   Er("Er",this,other.Er),
   Mchi("Mchi",this,other.Mchi),
   sigma_nuc("sigma_nuc",this,other.sigma_nuc),
   A("A",this,other.A),
   v0("v0",this,other.v0),
   vesc("vesc",this,other.vesc)
 {
 TF1 tmpfunc(other.n_func);
 n_func=tmpfunc; 
 } 



 Double_t RooWimpNew::evaluate() const 
 { 
double rate=0; 
 

//const double v0=220;
//const double vesc=650;
const double rho=0.3;
const double vearth=232;

const double pi=TMath::Pi();

// Velocity distribution integral from Phys Rev D 74, 043531 (2006), Savage, Freese, Gondolo



//if n_elements(A) ne 1 then print,"pbl with A"
double Mn=0.932*A ;         // mass of target nucleus, 1 amu = 931.46 MeV/c^2 = 0.93146 GeV/c^2
double Mp=0.938 ;           // proton mass in GeV/c^2
double Erec=Er;//+0.00001;	           // Eviter valeur nulle..

// Units: Er keV; Mn,Mchi GeV; v0,vesc km/s; rho GeV/cm^3; sigma pb
// rate evts/kg.d.keV
double eV=1.6E-19;              // [J]
double keV=eV*1E3;
double GeV=eV*1E9;
double fm=1E-15;
double pb=1E-40 ;              // 1 picobarn=10^-40 m^2
double hbarc=1.054E-34*3.e8;    // [J*m]
double kmpersec=1000;          // [m/s]
double cm3=1E6;                // [m^3]
double c2=9E16;                // [m^2/s^2]

// SPIN-IDEPENDENT COHERENT DIFFUSION, f_n=f_p
double mu=Mchi*Mn/(Mchi+Mn);                  // WIMP-nucleus reduced mass, in real units it would be mu=Mchi*Mn*GeV/((Mchi+Mn)*c2)
double mup=Mchi*Mp/(Mchi+Mp);                 // WIMP-proton  reduced mass, in real units it would be mup=Mchi*Mp*GeV/((Mchi+Mp)*c2)
double shigma=sigma_nuc*pow(mu/mup,2)*pow(A,2);            // [m^2]


// NUCLEAR FORM FACTOR (from Lewin & Smith, 1996)
double q=sqrt(2*Mn*GeV*Erec*keV) ;                   							// [MeV], array
double ss=0.9*fm;											//Lewin p. 98
double aa=0.52*fm	;										//Lewin p. 98
double cc=(1.23*pow(A,1./3.)-0.6)*fm;
double rn=sqrt(pow(cc,2)+(7/3.)*pow(pi,2)*pow(aa,2)-5.*pow(ss,2));                            		// Lewin (4.11)
double qrn=q*rn/hbarc;
double formfactor=3*exp(-pow(q*ss/hbarc,2)/2.)*(sin(qrn)-qrn*cos(qrn))/(pow(qrn,3)) ;  			// Lewin (4.7)



// Vmin CALCULATION
double vmin=sqrt(Mn*Erec*keV*c2/(2*pow(mu,2)*GeV))/kmpersec;


// RATE CALCULATION
double eta=0;
double x=vmin/v0;                          // Adimensional velocities, SFG (12)
double y=vearth/v0;
double z=vesc/v0;

double w1=TMath::Abs(y-z);
double w2=y+z;



double Nesc=TMath::Erf(z)-2.*z*exp(-pow(z,2))/sqrt(pi);							//  Normalisation constant, SFG (8)

/*double small_inc=1E-10;
if (z< y && x<w1) {eta=1./(v0*y); }
else if (z> y && x<w1) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(x+y)-TMath::Erf(x-y)-4.*y*exp(-pow(z,2))/sqrt(pi)); }
else if (w1 <= x && x<w2) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(z)-TMath::Erf(x-y)-2.*(y+z-x)*exp(-pow(z,2))/sqrt(pi)); }
else if (w2 <= x ) {eta = 0; }
eta=eta+small_inc;*/

// -------------------------------------------------------------------------------------------------------------------------------------------------
//  N o u v e l l e   v e r s i o n  :   i n c l u t    u n   f a c t e u r   s u p p    p o u r   f a i r e  ->0   m a i s  > 0  
/*double offs=0.1;
double const_C=1/(2*Nesc*v0*y)*(TMath::Erf(z)-TMath::Erf(z-offs)-2*offs*exp(-z*z)/sqrt(pi));
double const_D=1/(Nesc*v0*y*sqrt(pi))*(exp(-z*z)-exp(-(z-1)*(z-offs)));


double const_a=y+z-offs;
double const_b=-2*const_C/(sqrt(pi)*const_D);

if (z< y && x<w1) {eta=1./(v0*y); }
else if (z> y && x<w1) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(x+y)-TMath::Erf(x-y)-4.*y*exp(-pow(z,2))/sqrt(pi)); }
else if (w1 <= x && x<w2-offs) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(z)-TMath::Erf(x-y)-2.*(y+z-x)*exp(-pow(z,2))/sqrt(pi)); }
else if (w2-offs<=x) {eta=const_C*(1-TMath::Erf((x-const_a)/const_b)); }*/

if (z< y && x<w1) {eta=1./(v0*y); }
else if (z> y && x<w1) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(x+y)-TMath::Erf(x-y)-4.*y*exp(-pow(z,2))/sqrt(pi)); }
else if (w1 <= x && x<w2) {eta=1./(2*Nesc*v0*y)*(TMath::Erf(z)-TMath::Erf(x-y)-2.*(y+z-x)*exp(-pow(z,2))/sqrt(pi)); }
else if (w2<=x) {eta=0;}


rate=140.2*((n_func.Eval(Er))*shigma*pb*pow(formfactor,2)*rho*cm3*pow(c2,2)*(eta)*3600*24/(2*Mchi*pow(mu,2)*GeV*1.E6*kmpersec)+1E-8);  // [counts/kg/day/keV]

return rate; 
 } 



/*double s_cond=33.6989;
double m_cond=535.455;
double D_cond= 1/(sqrt(2*pi)*s_cond);
double A_cond=84.7824;
double kurt_cond= 1.87834e-06;

//Vraie expression
//double result=A_cond*D_cond*exp(-0.5*pow((vesc-m_cond)/s_cond,2)+kurt_cond*pow(vesc-m_cond,3))*0.5*(1-TMath::Erf((vesc-630)/(20)))*0.5*(1+TMath::Erf((vesc-490)/(20))); 

//Gaussienne approchÃ©e
//double result=A_cond*D_cond*exp(-0.5*pow((vesc-m_cond)/s_cond,2));

//double Mass=A_cond*D_cond*exp(-0.5*pow((Mchi-10)/1,2));
//double Ener=A_cond*D_cond*exp(-0.5*pow((Er-12)/1,2));

//!!!!!!!!!!!!!!!!!!
// Rajouter eta et n_func!! (n_func.Eval(Er))

//rate=result*pow(Er-30,2)*shigma*pb*pow(formfactor,2)*rho*cm3*pow(c2,2)*3600*24/(2*Mchi*pow(mu,2)*GeV*1.E6*kmpersec);  // [counts/kg/day/keV]
//rate=result*Mass*Ener;*/

